#!/usr/bin/env python3

import configparser
import gi
gi.require_version('Gtk', '3.0')
from gi.repository import Gtk
import os
import os.path
import shutil
import subprocess

CONFIG_SECTION_DAEMONS = 'daemons'
CONFIG_SECTION_APPLICATIONS = 'applications'
CONFIG_SECTION_APPEARANCE = 'appearance'
CONFIG_SECTION_INPUT = 'input'
DIRNAME = 'pademelon'
TEST_TIMEOUT = 1    # in seconds
TITLE = 'Pademelon Settings'
PREFERENCE_NONE = 'none'


class ApplicationBox(Gtk.Box):
    def __init__(self, window, config_section, cname, clabel):
        super().__init__()
        global categories
        self.window = window
        self.config_section = config_section
        self.cname = cname
        self.clabel = clabel

        if cname in categories:
            self.applications = categories[cname]
        else:
            self.applications = []

        self.frame = Gtk.Frame()
        self.frame.set_label(clabel)
        self.frame.set_margin_end(5)
        self.frame.set_margin_start(5)

        self.pack_start(self.frame, True, True, 0)


class ApplicationSelectionBox(ApplicationBox):
    def __init__(self, window, config_section, cname, clabel):
        super().__init__(window, config_section, cname, clabel)
        global config

        self.inner_box = Gtk.Box()
        self.settings_button = Gtk.Button(label='Settings')
        self.settings_button.connect('clicked', self.on_button_clicked)
        self.application_selection_box = Gtk.ComboBoxText()
        self.application_selection_box.connect("changed", self.on_combo_changed)

        select = len(self.applications) + 1      # select default item
        for application in self.applications:
            self.application_selection_box.append_text(application.display_name + self.application_test_str(application))
            if self.config_section in config \
                    and self.cname in config[self.config_section] \
                    and application.id_name == config[self.config_section][cname]:
                        # @TODO generalize section name for applications
                select = self.applications.index(application)     # select config item if existent
                self.application_selection_box.set_tooltip_text(application.desc)
        if self.config_section in config \
                and self.cname in config[self.config_section] \
                and PREFERENCE_NONE == config[self.config_section][cname]:
            select = len(self.applications)
        self.application_selection_box.append_text('None')
        self.application_selection_box.append_text('Default')
        self.application_selection_box.set_active(select)

        self.inner_box.pack_start(self.application_selection_box, True, True, 5)
        self.inner_box.pack_end(self.settings_button, False, False, 5)
        self.frame.add(self.inner_box)

    def application_test_str(self, application):
        if application.test():
            return ''
        else:
            return ' (not installed)'

    def on_button_clicked(self, source):
        if source is not self.settings_button:
            return
        selected = self.selected_application()
        if selected == None:
            return
        if selected.settings == '':
            dialog = Gtk.MessageDialog(
                    transient_for = self.window,
                    message_type = Gtk.MessageType.ERROR,
                    buttons = Gtk.ButtonsType.OK,
                    text = 'No settings file or application found for "{}".'.format(selected.display_name))
            dialog.set_title('No Settings Available')
            dialog.show()
            dialog.run()
            dialog.destroy()
            return
        if selected.settings.startswith("config://"):
            path = os.getenv('XDG_CONFIG_HOME', os.path.expanduser('~/.config'))
            spawn(['xdg-open', os.path.join(path, selected.settings[len('config://'):])], check_dependency=True, parent=self.window)
        elif selected.settings.startswith('file://'):
            spawn(['xdg-open', selected.settings[len('file://'):]], check_dependency=True, parent=self.window)
        else:
            spawn(['/bin/sh', '-c', selected.settings], check_dependency=True, parent=self.window)

    def on_combo_changed(self, combo):
        selected = self.selected_application();
        if selected == None:
            if self.application_selection_box.get_active() == len(self.applications):   # none
                if self.config_section not in config:
                    config[self.config_section] = {}
                config[self.config_section][self.cname] = PREFERENCE_NONE
            else: # default
                if self.config_section in config and self.cname in config[self.config_section]:
                    config.remove_option(self.config_section, self.cname)
                self.application_selection_box.set_has_tooltip(False)
        else:
            if not selected.test():
                dialog = Gtk.MessageDialog(
                        transient_for = self.window,
                        message_type = Gtk.MessageType.WARNING,
                        buttons = Gtk.ButtonsType.OK,
                        text = 'You selected a program, that is not installed or not available: "{}". '.format(selected.display_name)
                               + 'You might want want to either install that program or choose another one.')
                dialog.set_title('Program not installed')
                dialog.show()
                dialog.run()
                dialog.destroy()
            if self.config_section not in config:
                config[self.config_section] = {}
            config[self.config_section][self.cname] = selected.id_name
            self.application_selection_box.set_tooltip_text(selected.desc)

    def selected_application(self):
        selection = self.application_selection_box.get_active()
        if selection >= len(self.applications):  # default, none
            return None
        else:
            return self.applications[selection]



class DesktopApplication():
    def __init__(self, id_name):
        self.id_name = id_name
        self.display_name = id_name
        self.desc = ""
        self.category = "optional"
        self.cdefault = False
        self.launch_cmd = ""
        self.test_cmd = ""
        self.settings = ""
        self.tested = False
        self.test_result = False

    def run_test(self):
        try:
            cp = subprocess.run(self.test_cmd, shell=True, timeout=TEST_TIMEOUT)
            self.tested = True
            self.test_result = cp.returncode == 0
        except subprocess.TimeoutExpired:
            self.tested = True
            self.test_result = 0
        return self.test_result


    def test(self):
        if not self.tested:
            self.run_test()
        return self.test_result


class MainWindow(Gtk.Window):
    def __init__(self):
        super().__init__(title=TITLE)
        self.notebook_pages = []
        self.set_border_width(10)
        self.set_default_size(600, 800)

        # create ui elements
        self.main_box = Gtk.Box()
        self.main_box.set_orientation(Gtk.Orientation.VERTICAL)
        self.notebook = Gtk.Notebook()
        self.action_bar = Gtk.ActionBar()
        self.cancel_button = Gtk.Button(label="Cancel")
        self.cancel_button.connect('clicked', self.on_button_clicked)
        self.save_button = Gtk.Button(label="Save")
        self.save_button.connect('clicked', self.on_button_clicked)
        self.quit_button = Gtk.Button(label="Save & Exit")
        self.quit_button.connect('clicked', self.on_button_clicked)

        # add pages for notebook
        self.notebook_pages.append(('Daemons', self.daemon_page()))
        self.notebook_pages.append(('Applications', self.application_page()))
        self.notebook_pages.append(('System', self.system_page()))
        for page in self.notebook_pages:
            self.notebook.append_page(page[1], Gtk.Label(label=page[0]))

        # compose ui
        self.main_box.pack_start(self.notebook, True, True, 0)
        self.main_box.pack_end(self.action_bar, False, False, 0)
        self.action_bar.pack_end(self.quit_button)
        self.action_bar.pack_end(self.save_button)
        self.action_bar.pack_end(self.cancel_button)

        self.add(self.main_box)
        self.show_all()
        self.connect('destroy', Gtk.main_quit)

    def application_page(self):
        self.application_rows = []

        # init applications box
        self.applications_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        self.applications_box.set_spacing(5)

        # create application frames
        self.application_rows.append(ApplicationSelectionBox(self, CONFIG_SECTION_APPLICATIONS, 'terminal', 'Terminal Emulator'))
        self.application_rows.append(ApplicationSelectionBox(self, CONFIG_SECTION_APPLICATIONS, 'browser', 'Web Browser'))

        # add application frames to box
        for ar in self.application_rows:
            self.applications_box.pack_start(ar, False, False, 5)

        return self.applications_box


    def daemon_page(self):
        self.daemon_rows = []

        # init daemons box
        self.daemons_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        self.daemons_box.set_spacing(5)
        self.applet_box = OptionalApplicationBox(self, CONFIG_SECTION_DAEMONS, 'applets', 'Applets')

        # create daemon frames
        self.daemon_rows.append(ApplicationSelectionBox(self, CONFIG_SECTION_DAEMONS, 'window-manager', 'Window Manager'))
        self.daemon_rows.append(ApplicationSelectionBox(self, CONFIG_SECTION_DAEMONS, 'compositor', 'Compositor'))
        self.daemon_rows.append(ApplicationSelectionBox(self, CONFIG_SECTION_DAEMONS, 'hotkeys', 'Hotkey Daemon'))
        self.daemon_rows.append(ApplicationSelectionBox(self, CONFIG_SECTION_DAEMONS, 'notifications', 'Notification Daemon'))
        self.daemon_rows.append(ApplicationSelectionBox(self, CONFIG_SECTION_DAEMONS, 'polkit', 'Polkit'))
        self.daemon_rows.append(ApplicationSelectionBox(self, CONFIG_SECTION_DAEMONS, 'power', 'Power Management'))
        self.daemon_rows.append(ApplicationSelectionBox(self, CONFIG_SECTION_DAEMONS, 'status', 'Status Script or Bar'))

        # add daemon frames to box
        for dr in self.daemon_rows:
            self.daemons_box.pack_start(dr, False, False, 5)

        self.daemons_box.pack_start(self.applet_box, False, False, 5)

        return self.daemons_box

    def system_page(self):
        # init main box
        self.system_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        self.system_box.set_spacing(5)

        # display frame
        self.display_frame = Gtk.Frame()
        self.display_frame.set_label('Display')
        self.display_frame.set_margin_end(5)
        self.display_frame.set_margin_start(5)
        self.display_box = Gtk.Box()
        self.arandr_button = Gtk.Button(label='Configure display layout')
        self.arandr_button.connect('clicked', self.on_button_clicked)
        self.wallpaper_button = Gtk.Button(label='Choose wallpaper')
        self.wallpaper_button.connect('clicked', self.on_button_clicked)
        self.display_box.pack_start(self.arandr_button, True, True, 5)
        self.display_box.pack_start(self.wallpaper_button, True, True, 5)
        self.display_frame.add(self.display_box)

        # input frame
        self.input_frame = Gtk.Frame()
        self.input_frame.set_label('Input')
        self.input_frame.set_margin_end(5)
        self.input_frame.set_margin_start(5)
        self.input_box = Gtk.Box()
        self.keyboard_label = Gtk.Label()
        self.keyboard_label.set_text('Keyboard Layout:')
        self.keyboard_entry = Gtk.Entry()
        self.keyboard_entry.connect("changed", self.on_entry_changed)
        if CONFIG_SECTION_INPUT in config and 'keyboard-layout' in config[CONFIG_SECTION_INPUT]:
            self.keyboard_entry.set_text(config[CONFIG_SECTION_INPUT]['keyboard-layout'])
        self.input_box.pack_start(self.keyboard_label, False, False, 5)
        self.input_box.pack_start(self.keyboard_entry, True, True, 5)
        self.input_frame.add(self.input_box)

        # add menu items
        self.system_box.add(self.display_frame)
        self.system_box.add(self.input_frame)

        return self.system_box

    def on_button_clicked(self, source):
        global config
        if source == self.arandr_button:
            spawn("arandr", check_dependency=True, parent=self)
        elif source == self.wallpaper_button:
            dialog = Gtk.FileChooserDialog(title="Choose background image",
                    parent=self,
                    action=Gtk.FileChooserAction.OPEN)
            dialog.add_buttons(
                    Gtk.STOCK_CANCEL,
                    Gtk.ResponseType.CANCEL,
                    Gtk.STOCK_OPEN,
                    Gtk.ResponseType.OK)
            response = dialog.run()
            if response == Gtk.ResponseType.OK:
                print("Setting new wallpaper: " + dialog.get_filename())
                spawn(["pademelon-tools", "set-wallpaper", dialog.get_filename()], check_dependency=True, parent=self)
            dialog.destroy()
        # action bar
        elif source == self.cancel_button:
            Gtk.main_quit()
        elif source == self.save_button:
            write_config(config, user_config_path('pademelon.conf'), self)
        elif source == self.quit_button:
            write_config(config, user_config_path('pademelon.conf'), self)
            Gtk.main_quit()

    def on_entry_changed(self, entry):
        global config
        if entry == self.keyboard_entry:
            if CONFIG_SECTION_INPUT not in config:
                config[CONFIG_SECTION_INPUT] = {}
            config[CONFIG_SECTION_INPUT]['keyboard-layout'] = self.keyboard_entry.get_text()


class OptionalApplicationBox(ApplicationBox):
    def __init__(self, window, config_section, cname, clabel):
        super().__init__(window, config_section, cname, clabel)
        global config

        self.inner_box = Gtk.FlowBox()
        self.inner_box.set_selection_mode(Gtk.SelectionMode.NONE)
        self.check_buttons = []

        if self.config_section in config and cname in config[self.config_section]:
            self.activated_applications = set(config[self.config_section][cname].split(' '))
        else:
            self.activated_applications = set()

        for application in self.applications:
            cb = Gtk.CheckButton(label=application.display_name)
            cb.connect("toggled", self.on_button_toggled, "1")
            cb.set_tooltip_text(application.desc)
            if application.id_name in self.activated_applications:
                cb.set_active(True)
            self.check_buttons.append(cb)
            if application.test():
                self.inner_box.add(cb)

        self.frame.add(self.inner_box)

    def on_button_toggled(self, button, name):
        global config
        for cb in self.check_buttons:
            application_id_name = self.applications[self.check_buttons.index(cb)].id_name
            if cb.get_active() and application_id_name not in self.activated_applications:
                self.activated_applications.add(application_id_name)
            elif not cb.get_active() and application_id_name in self.activated_applications:
                self.activated_applications.remove(application_id_name)
        if self.config_section not in config:
            config[self.config_section] = {}
        config[self.config_section][self.cname] = ' '.join(self.activated_applications)


def check_binary_dependency(executable, parent=None):
    if type(executable) == str:
        temp = shutil.which(executable)
    else:
        temp = shutil.which(executable[0])
    if temp == None:
        msg = "You are missing the binary dependency: {}\nPlease use your package manager to install it manually."
        msg = msg.format(executable)
        dialog = Gtk.MessageDialog(
                transient_for = parent,
                message_type = Gtk.MessageType.ERROR,
                buttons = Gtk.ButtonsType.OK,
                text = msg)
        dialog.set_title("Missing Binary Dependency")
        dialog.show()
        dialog.run()
        dialog.destroy()
        return False
    else:
        return True


def read_config(paths):
    config = configparser.ConfigParser()
    config.read(paths)
    return config

def read_desktop_application_files(paths):
    categories = {}
    files = []

    for path in paths:
        if (os.path.exists(path)):
            files.extend([f.path for f in os.scandir(path) if f.is_file()])

    # read config files
    config = configparser.ConfigParser()
    if len(config.read(files)) == 0:
        return None

    for application_id_name in config.sections():
        application = DesktopApplication(application_id_name)
        try:
            application.display_name = config[application_id_name]['name']
        except KeyError:
            print("Error while reading application config '{}': 'name' not specified".format(application_id_name))

        # optional values
        if ('default' in config[application_id_name]):
            application.cdefault = str_to_bool(config[application_id_name]['default'])
        if ('description' in config[application_id_name]):
            application.desc = config[application_id_name]['description']
        if ('category' in config[application_id_name]):
            application.category = config[application_id_name]['category']
        if ('command' in config[application_id_name]):
            application.launch_cmd = config[application_id_name]['command']
        if ('test' in config[application_id_name]):
            application.test_cmd = config[application_id_name]['test']
        if ('settings' in config[application_id_name]):
            application.settings = config[application_id_name]['settings']

        # add application to the right category
        if (application.category not in categories):
            categories[application.category] = []
        categories[application.category].append(application)

    return categories


def spawn(executable, check_dependency=False, parent=None):
    if check_dependency and not check_binary_dependency(executable, parent):
        return
    if type(executable) == str:
        temp = shutil.which(executable)
    else:
        temp = shutil.which(executable[0])
    if temp != None:
        subprocess.Popen(executable)


def str_to_bool(s):
    return s.lower() in ['true', '1']


def system_config_path(file=''):
    return os.path.join('/etc', DIRNAME, file)


def system_data_path(file=''):
    return os.path.join('/usr/share', DIRNAME, file)


def system_local_data_path(file=''):
    return os.path.join('/usr/share/local', DIRNAME, file)


def user_config_path(file=''):
    path = os.getenv('XDG_CONFIG_HOME', os.path.expanduser('~/.config'))
    return os.path.join(path, DIRNAME, file)


def user_data_path(file=''):
    path = os.getenv('XDG_DATA_HOME', os.path.expanduser('~/.local/share'))
    return os.path.join(path, DIRNAME, file)


def write_config(config, path, parent=None):
    if not os.path.exists(os.path.dirname(path)):   # give user chance to create parent dir
        dialog = Gtk.MessageDialog(
                transient_for = parent,
                message_type = Gtk.MessageType.QUESTION,
                buttons = Gtk.ButtonsType.YES_NO,
                text = 'Parent directory for config file does not exist. Create it now?')
        dialog.set_title('Config Directory')
        dialog.show()
        response = dialog.run()
        if response == Gtk.ResponseType.YES:
            os.makedirs(os.path.dirname(path))
        dialog.destroy()
    if not os.path.exists(os.path.dirname(path)):
        dialog = Gtk.MessageDialog(
                transient_for = parent,
                message_type = Gtk.MessageType.ERROR,
                buttons = Gtk.ButtonsType.OK,
                text = 'Unable to write config to "{}". Parent directory does not exist.'.format(path))
        dialog.set_title('Unable to Write Config')
        dialog.show()
        dialog.run()
        dialog.destroy()
        return
    if os.path.exists(path):
        pass # file already exists - overwrite?
    file = open(path, 'w+')
    config.write(file)
    file.close()


if __name__ == '__main__':
    categories = read_desktop_application_files([system_data_path('applications'), system_local_data_path('applications'),
            user_data_path('applications'), '/home/jzbor/Programming/C/pademelon/applications'])
    config = read_config([system_config_path('pademelon.conf'), user_config_path('pademelon.conf'),
            '/home/jzbor/Programming/C/pademelon/pademelon.conf'])
    MainWindow()
    Gtk.main()
